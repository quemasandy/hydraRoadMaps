# All Code Context

================================================================================
FILE: README.md
================================================================================
# Enhanced Layered Architecture (afterV2)

This directory contains a comprehensive, didactic example of **Clean Architecture**.

It demonstrates how to separate concerns into **Presentation**, **Domain**, and **Infrastructure** layers, with specific examples for payment gateways, queues, and databases.

## Directory Structure

The project is organized as follows:

```
afterV2/
‚îú‚îÄ‚îÄ domain/                  # üß† The Brain (Pure Business Logic)
‚îÇ   ‚îú‚îÄ‚îÄ entities/            # User, Order
‚îÇ   ‚îú‚îÄ‚îÄ interfaces/          # Ports (IUserRepository, IPaymentGateway...)
‚îÇ   ‚îî‚îÄ‚îÄ services/            # UserService, OrderService
‚îú‚îÄ‚îÄ infrastructure/          # üîå The Plugs (External Tools)
‚îÇ   ‚îú‚îÄ‚îÄ repositories/        # MongoUserRepository, SqlUserRepository
‚îÇ   ‚îú‚îÄ‚îÄ dtos/                # UserPersistenceDTO, UserDocument
‚îÇ   ‚îú‚îÄ‚îÄ mappers/             # UserMapper, MongoUserMapper
‚îÇ   ‚îú‚îÄ‚îÄ email/               # SmtpEmailClient
‚îÇ   ‚îú‚îÄ‚îÄ payment/             # Cybersource, Lyra
‚îÇ   ‚îî‚îÄ‚îÄ queue/               # AwsSqs, RabbitMq
‚îú‚îÄ‚îÄ presentation/            # üó£Ô∏è The Voice (IO)
‚îÇ   ‚îú‚îÄ‚îÄ controllers/         # UserController, OrderController
‚îÇ   ‚îú‚îÄ‚îÄ dtos/                # RegisterUserDto, CreateOrderDto
‚îÇ   ‚îú‚îÄ‚îÄ serializers/         # UserSerializer
‚îÇ   ‚îî‚îÄ‚îÄ views/               # ConsoleView
‚îî‚îÄ‚îÄ main.ts                  # üèóÔ∏è The Builder (Composition Root)
```

## Key Concepts Demonstrated

### 1. Dependency Inversion
The **Domain** layer defines interfaces (Ports) like `IPaymentGateway`. The **Infrastructure** layer implements them (`CybersourcePaymentGateway`). The domain *never* imports from infrastructure.

### 2. Dependency Injection
In `main.ts`, we wire everything together. This allows us to swap implementations easily:

```typescript
// main.ts
// Switching databases is as easy as changing one line!
// const userRepo = new SqlUserRepository();
const userRepo = new MongoUserRepository();

// Switching payment providers
const paymentGateway = new LyraPaymentGateway();
```

### 3. Rich Domain Model
Entities like `User` and `Order` contain business logic (e.g., `markAsPaid()`, `deactivate()`), not just data.

## How to Run

You can run the example using `ts-node`:

```bash
npx ts-node src/01-fundamentals/01-exercises/07-srp/07-layers-example/afterV2/main.ts
```

### Expected Output
You will see logs indicating the flow through the layers:
1.  **Controller** receives request.
2.  **Domain Service** executes logic.
3.  **Infrastructure** performs external actions (SQL, Mongo, API calls).
4.  **View** renders the result.

================================================================================
FILE: domain/entities/Order.ts
================================================================================
/**
 * Archivo: Order.ts
 * UBICACI√ìN: Capa de Dominio / Entidades
 *
 * Representa una orden de compra en el sistema.
 * AHORA ES UN AGGREGATE ROOT (Ra√≠z de Agregado).
 */

import { Money } from '../value-objects/Money';

// Value Object interno del Agregado
export class OrderItem {
  constructor(
    public readonly productId: string,
    public readonly price: Money, // VO!
    public readonly quantity: number
  ) {
    if (quantity <= 0) throw new Error("La cantidad debe ser mayor a 0.");
    // El precio negativo se valida dentro del VO Money, pero aqu√≠ validamos cantidad.
  }

  get total(): Money {
    return this.price.multiply(this.quantity);
  }
}

export class Order {
  private _items: OrderItem[] = [];

  constructor(
    public readonly id: string,
    public readonly userId: string,
    public readonly status: 'PENDING' | 'PAID' | 'FAILED' = 'PENDING',
    public readonly createdAt: Date = new Date()
  ) {}

  /**
   * REGLA DE NEGOCIO (Aggregate Invariant):
   * Agregar un item a la orden.
   */
  addItem(productId: string, price: Money, quantity: number): void {
    if (this.status !== 'PENDING') {
      throw new Error("No se pueden agregar items a una orden cerrada.");
    }
    this._items.push(new OrderItem(productId, price, quantity));
  }

  /**
   * Propiedad calculada: El total de la orden es la suma de sus items.
   */
  get totalAmount(): Money {
    // Si no hay items, retornamos 0 USD por defecto.
    if (this._items.length === 0) {
      return new Money(0, 'USD'); 
    }
    
    // Asumimos que todos los items tienen la misma moneda para este ejemplo simple.
    // Una implementaci√≥n real manejar√≠a conversi√≥n de monedas o validar√≠a que todos sean la misma.
    const currency = this._items[0].price.currency;
    const initial = new Money(0, currency);

    return this._items.reduce((sum, item) => sum.add(item.total), initial);
  }

  get items(): ReadonlyArray<OrderItem> {
    return this._items;
  }

  /**
   * REGLA DE NEGOCIO:
   * Marcar la orden como pagada.
   */
  markAsPaid(): Order {
    if (this.status === 'PAID') {
      throw new Error("La orden ya est√° pagada.");
    }
    // En un enfoque inmutable puro devolver√≠amos una nueva instancia con los mismos items
    // Para simplificar este ejemplo, mutamos el estado interno o recreamos copiando items
    const paidOrder = new Order(this.id, this.userId, 'PAID', this.createdAt);
    paidOrder._items = [...this._items]; // Copiamos los items
    return paidOrder;
  }

  /**
   * REGLA DE NEGOCIO:
   * Marcar la orden como fallida.
   */
  markAsFailed(): Order {
    const failedOrder = new Order(this.id, this.userId, 'FAILED', this.createdAt);
    failedOrder._items = [...this._items];
    return failedOrder;
  }
}

================================================================================
FILE: domain/entities/User.ts
================================================================================
/**
 * Archivo: User.ts
 * UBICACI√ìN: Capa de Dominio / Entidades
 *
 * ¬øQU√â ES UNA ENTIDAD?
 * - Es un objeto de negocio con identidad √∫nica (ID).
 * - Contiene datos y comportamiento puro del negocio.
 * - NO depende de base de datos, frameworks ni UI.
 */

import { Email } from '../value-objects/Email';

export class User {
  // Propiedades privadas para encapsulamiento
  constructor(
    public readonly id: string,
    public readonly email: Email, // Value Object!
    public readonly passwordHash: string,
    public readonly isActive: boolean = true
  ) {}

  /**
   * REGLA DE NEGOCIO:
   * Un usuario puede desactivarse, pero solo si est√° activo.
   */
  deactivate(): User {
    if (!this.isActive) {
      throw new Error("El usuario ya est√° inactivo.");
    }
    // Retornamos una nueva instancia para inmutabilidad (opcional pero recomendado)
    return new User(this.id, this.email, this.passwordHash, false);
  }

  /**
   * REGLA DE NEGOCIO:
   * Validaci√≥n de dominio simple.
   * (Ahora esto es redundante porque el VO Email ya se valida a s√≠ mismo, pero lo mantenemos por compatibilidad o l√≥gica extra)
   */
  hasValidEmail(): boolean {
    return this.email.getValue().includes('@');
  }
}

================================================================================
FILE: domain/interfaces/IEmailService.ts
================================================================================
/**
 * Archivo: IEmailService.ts
 * UBICACI√ìN: Capa de Dominio / Interfaces (Puertos)
 *
 * Contrato para enviar correos electr√≥nicos.
 * El dominio no sabe si se usa SendGrid, AWS SES o SMTP local.
 */

export interface IEmailService {
  sendWelcomeEmail(email: string, name: string): Promise<void>;
  sendOrderConfirmation(email: string, orderId: string): Promise<void>;
}

================================================================================
FILE: domain/interfaces/IPaymentGateway.ts
================================================================================
/**
 * Archivo: IPaymentGateway.ts
 * UBICACI√ìN: Capa de Dominio / Interfaces (Puertos)
 *
 * Contrato para procesar pagos.
 * El dominio no sabe si se usa Stripe, PayPal, Cybersource o Lyra.
 */

export interface IPaymentGateway {
  processPayment(amount: number, currency: string, source: string): Promise<boolean>;
}

================================================================================
FILE: domain/interfaces/IQueueService.ts
================================================================================
/**
 * Archivo: IQueueService.ts
 * UBICACI√ìN: Capa de Dominio / Interfaces (Puertos)
 *
 * Contrato para enviar mensajes a colas.
 * El dominio no sabe si se usa AWS SQS, RabbitMQ o Kafka.
 */

export interface IQueueService {
  publishMessage(queueName: string, message: any): Promise<void>;
}

================================================================================
FILE: domain/interfaces/IUserRepository.ts
================================================================================
/**
 * Archivo: IUserRepository.ts
 * UBICACI√ìN: Capa de Dominio / Interfaces (Puertos)
 *
 * ¬øQU√â ES UN PUERTO (PORT)?
 * - Es un contrato que define QU√â necesita el dominio para funcionar.
 * - NO dice C√ìMO se hace (eso es problema de la infraestructura).
 * - Permite desacoplar el dominio de la base de datos.
 */

import { User } from '../entities/User';

export interface IUserRepository {
  save(user: User): Promise<User>;
  findByEmail(email: string): Promise<User | null>;
  findById(id: string): Promise<User | null>;
}

================================================================================
FILE: domain/services/OrderService.ts
================================================================================
/**
 * Archivo: OrderService.ts
 * UBICACI√ìN: Capa de Dominio / Servicios
 *
 * Servicio para gestionar √≥rdenes de compra.
 * Orquesta pagos, colas y notificaciones.
 */

import { Order } from '../entities/Order';
import { IPaymentGateway } from '../interfaces/IPaymentGateway';
import { IQueueService } from '../interfaces/IQueueService';
import { IEmailService } from '../interfaces/IEmailService';
import { Money } from '../value-objects/Money';

export class OrderService {
  constructor(
    private readonly paymentGateway: IPaymentGateway,
    private readonly queueService: IQueueService,
    private readonly emailService: IEmailService
  ) {}

  async createOrder(userId: string, items: Array<{productId: string, price: number, quantity: number}>, paymentSource: string): Promise<Order> {
    console.log(`[Dominio] Creando orden para usuario ${userId} con ${items.length} items...`);

    // 1. Crear la orden en estado PENDING (El agregado nace vac√≠o)
    let order = new Order(Date.now().toString(), userId);

    // 2. Hidratar el agregado (Aqu√≠ se validan invariantes de cada item)
    for (const item of items) {
      // Creamos Value Object Money aqu√≠
      const priceVO = new Money(item.price, 'USD'); // Asumimos USD para simplificar
      order.addItem(item.productId, priceVO, item.quantity);
    }
    
    // Invariante del Agregado: ¬øOrden vac√≠a?
    if (order.totalAmount.amount <= 0) { // Accedemos al valor primitivo para chequear
      throw new Error("La orden debe tener al menos un item con valor.");
    }

    const totalAmount = order.totalAmount;

    try {
      // 3. Procesar pago (usando el puerto de pago)
      // Nota: El dominio le pide al agregado "dame tu total" para cobrar. 
      // El puerto espera primitivos (number), as√≠ que desempaquetamos el VO.
      const paymentSuccess = await this.paymentGateway.processPayment(totalAmount.amount, totalAmount.currency, paymentSource);

      if (paymentSuccess) {
        // 4. Si el pago es exitoso, marcar como pagada (Mutaci√≥n de estado del agregado)
        order = order.markAsPaid();
        
        // 5. Publicar evento de integraci√≥n (Side Effect)
        await this.queueService.publishMessage('orders_queue', {
          type: 'ORDER_PAID',
          orderId: order.id,
          amount: totalAmount.amount,
          currency: totalAmount.currency
        });

        // 6. Enviar confirmaci√≥n por email
        await this.emailService.sendOrderConfirmation("user@example.com", order.id); 
        
        console.log(`[Dominio] Orden ${order.id} procesada exitosamente. Total: ${totalAmount.toString()}`);
      } else {
        // Pago rechazado
        order = order.markAsFailed();
        console.warn(`[Dominio] Pago rechazado para orden ${order.id}.`);
      }

    } catch (error) {
      console.error(`[Dominio] Error procesando orden: ${error}`);
      order = order.markAsFailed();
    }

    return order;
  }
}

================================================================================
FILE: domain/services/UserService.ts
================================================================================
/**
 * Archivo: UserService.ts
 * UBICACI√ìN: Capa de Dominio / Servicios
 *
 * ¬øQU√â HACE UN SERVICIO DE DOMINIO?
 * - Orquesta la l√≥gica de negocio pura.
 * - Utiliza los puertos (interfaces) para interactuar con el mundo exterior.
 * - Implementa los casos de uso (ej. Registrar Usuario).
 */

import { User } from '../entities/User';
import { IUserRepository } from '../interfaces/IUserRepository';
import { IEmailService } from '../interfaces/IEmailService';
import { Email } from '../value-objects/Email';

export class UserService {
  // Inyecci√≥n de dependencias a trav√©s del constructor
  // Dependemos de abstracciones (Interfaces), NO de implementaciones concretas.
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly emailService: IEmailService
  ) {}

  async registerUser(email: string, passwordPlain: string): Promise<User> {
    console.log(`[Dominio] Iniciando registro para ${email}...`);

    const emailVO = new Email(email); // Invariantes se validan aqu√≠

    // 1. REGLA DE NEGOCIO: Verificar si el usuario ya existe
    const existingUser = await this.userRepository.findByEmail(emailVO.getValue());
    if (existingUser) {
      throw new Error("El usuario ya est√° registrado.");
    }

    // 2. REGLA DE NEGOCIO: Validar dominio prohibido (ejemplo did√°ctico)
    if (emailVO.getValue().endsWith('@evil.com')) {
      throw new Error("Regla de Negocio: No se permiten usuarios de evil.com");
    }

    // 3. Crear la entidad
    const passwordHash = `hashed_${passwordPlain}`;
    const newUser = new User(
      Date.now().toString(), // ID temporal
      emailVO,
      passwordHash
    );

    // 4. Persistir usando el puerto
    const savedUser = await this.userRepository.save(newUser);

    // 5. Efecto secundario: Enviar email de bienvenida
    await this.emailService.sendWelcomeEmail(savedUser.email.getValue(), "Nuevo Usuario");

    console.log(`[Dominio] Usuario registrado exitosamente: ${savedUser.id}`);
    return savedUser;
  }
}

================================================================================
FILE: domain/value-objects/Email.ts
================================================================================
/**
 * Archivo: Email.ts
 * UBICACI√ìN: Capa de Dominio / Value Objects
 *
 * ¬øQU√â ES UN VALUE OBJECT?
 * - Se define por su valor, no por su identidad.
 * - Es inmutable.
 * - Se valida a s√≠ mismo al nacer.
 */
export class Email {
  private readonly value: string;

  constructor(value: string) {
    if (!value) {
      throw new Error("El email no puede estar vac√≠o.");
    }
    if (!value.includes('@')) {
      throw new Error("El email debe contener un '@'.");
    }
    // M√°s validaciones aqu√≠ (regex, etc.)
    this.value = value.trim().toLowerCase();
  }

  getValue(): string {
    return this.value;
  }

  equals(other: Email): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}

================================================================================
FILE: domain/value-objects/Money.ts
================================================================================
/**
 * Archivo: Money.ts
 * UBICACI√ìN: Capa de Dominio / Value Objects
 */
export class Money {
  constructor(
    public readonly amount: number,
    public readonly currency: string = 'USD'
  ) {
    if (amount < 0) {
      throw new Error("El monto no puede ser negativo.");
    }
    // Validaci√≥n simple de moneda
    if (currency.length !== 3) {
      throw new Error("La moneda debe tener 3 caracteres (ISO 4217).");
    }
  }

  add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error("No se pueden sumar monedas diferentes.");
    }
    return new Money(this.amount + other.amount, this.currency);
  }

  multiply(factor: number): Money {
    return new Money(this.amount * factor, this.currency);
  }

  equals(other: Money): boolean {
    return this.amount === other.amount && this.currency === other.currency;
  }

  toString(): string {
    return `${this.amount.toFixed(2)} ${this.currency}`;
  }
}

================================================================================
FILE: infrastructure/dtos/UserDocument.ts
================================================================================
/**
 * Archivo: UserDocument.ts
 * UBICACI√ìN: Capa de Infraestructura / DTOs
 *
 * ¬øQU√â ES UN DOCUMENTO DE MONGO?
 * - Representa la estructura de los documentos en la colecci√≥n 'users'.
 * - MongoDB usa '_id' en lugar de 'id'.
 * - Es flexible, pero en Typescript definimos una interfaz para seguridad.
 */

export interface UserDocument {
  _id: string;           // Mongo SIEMPRE usa _id
  email: string;
  password_hash: string;
  is_active: boolean;    // BSON soporta booleanos nativos
  created_at: Date;      // BSON soporta Date nativos
}

================================================================================
FILE: infrastructure/dtos/UserPersistenceDTO.ts
================================================================================
/**
 * Archivo: UserPersistenceDTO.ts
 * UBICACI√ìN: Capa de Infraestructura / DTOs
 *
 * ¬øQU√â ES UN DTO DE PERSISTENCIA?
 * - Representa C√ìMO est√°n guardados los datos en la base de datos realmente.
 * - Suele usar tipos primitivos (string, number, boolean) y nombres de columnas (snake_case).
 * - NO tiene l√≥gica de negocio. Es solo una bolsa de datos.
 */

export interface UserPersistenceDTO {
  user_id: string;       // En DB suele ser 'id' o 'user_id' -> snake_case
  email_address: string; // Imaginemos que la columna se llama 'email_address'
  password_hash: string; // Columna 'password_hash'
  is_active: number;     // En SQL a veces los booleanos son 0 o 1 (TINYINT)
  created_at: string;    // Fecha como string ISO o timestamp
}

================================================================================
FILE: infrastructure/email/SmtpEmailClient.ts
================================================================================
/**
 * Archivo: SmtpEmailClient.ts
 * UBICACI√ìN: Capa de Infraestructura / Email
 *
 * Implementaci√≥n concreta usando SMTP.
 */

import { IEmailService } from '../../domain/interfaces/IEmailService';

export class SmtpEmailClient implements IEmailService {
  async sendWelcomeEmail(email: string, name: string): Promise<void> {
    console.log(`[Infra - Email] Conectando a servidor SMTP... Enviando 'Bienvenida' a ${email}`);
  }

  async sendOrderConfirmation(email: string, orderId: string): Promise<void> {
    console.log(`[Infra - Email] Conectando a servidor SMTP... Enviando 'Confirmaci√≥n Orden ${orderId}' a ${email}`);
  }
}

================================================================================
FILE: infrastructure/mappers/MongoUserMapper.ts
================================================================================
/**
 * Archivo: MongoUserMapper.ts
 * UBICACI√ìN: Capa de Infraestructura / Mappers
 *
 * Mapeo espec√≠fico para MongoDB.
 * Maneja la idiosincrasia de Mongo (como el _id).
 */

import { User } from '../../domain/entities/User';
import { UserDocument } from '../dtos/UserDocument';
import { Email } from '../../domain/value-objects/Email';

export class MongoUserMapper {
  
  /**
   * BSON Document -> Domain Entity
   */
  static toDomain(doc: UserDocument): User {
    return new User(
      doc._id,           // Mapeamos _id -> id
      new Email(doc.email), // Reconstituir VO
      doc.password_hash,
      doc.is_active
    );
  }

  /**
   * Domain Entity -> BSON Document
   */
  static toPersistence(user: User): UserDocument {
    return {
      _id: user.id,      // Mapeamos id -> _id
      email: user.email.getValue(),
      password_hash: user.passwordHash,
      is_active: user.isActive,
      created_at: new Date() // Ojo: En un sistema real, mantendr√≠as la fecha de creaci√≥n original if exists
    };
  }
}

================================================================================
FILE: infrastructure/mappers/UserMapper.ts
================================================================================
/**
 * Archivo: UserMapper.ts
 * UBICACI√ìN: Capa de Infraestructura / Mappers
 *
 * ¬øQU√â ES UN MAPPER?
 * - Es el traductor entre el mundo de la Base de Datos (DTO) y el mundo del Dominio (Entidad).
 * - Mantiene limpia la Entidad: ella no sabe que en la DB el campo se llama 'is_active'.
 * - Mantiene limpia la DB: no le importa las reglas de negocio de la Entidad.
 */

import { User } from '../../domain/entities/User';
import { UserPersistenceDTO } from '../dtos/UserPersistenceDTO';
import { Email } from '../../domain/value-objects/Email';

export class UserMapper {
  
  /**
   * Convierte de DTO (Base de Datos) -> Entidad (Dominio)
   */
  static toDomain(raw: UserPersistenceDTO): User {
    // 1. Convertimos el 0/1 de SQL a boolean real
    const isActiveBoolean = raw.is_active === 1;

    // 1. Reconstruimos Value Objects
    // OJO: Aqu√≠ confiamos en la BD, o podr√≠amos try/catch si la BD est√° corrupta
    const emailVO = new Email(raw.email_address);

    // 2. Creamos la entidad
    return new User(
      raw.user_id,
      emailVO, // Pasamos el VO
      raw.password_hash,
      isActiveBoolean
    );
  }

  /**
   * Convierte de Entidad (Dominio) -> DTO (Base de Datos)
   * Prepara los datos para ser guardados.
   */
  static toPersistence(user: User): UserPersistenceDTO {
    return {
      user_id: user.id,
      email_address: user.email.getValue(), // Extraemos el valor primitivo
      password_hash: user.passwordHash,
      is_active: user.isActive ? 1 : 0, // Convertimos boolean a TINYINT
      created_at: new Date().toISOString() // Dato de auditor√≠a (ejemplo)
    };
  }
}

================================================================================
FILE: infrastructure/payment/CybersourcePaymentGateway.ts
================================================================================
/**
 * Archivo: CybersourcePaymentGateway.ts
 * UBICACI√ìN: Capa de Infraestructura / Payment
 *
 * Implementaci√≥n concreta para Cybersource.
 */

import { IPaymentGateway } from '../../domain/interfaces/IPaymentGateway';

export class CybersourcePaymentGateway implements IPaymentGateway {
  async processPayment(amount: number, currency: string, source: string): Promise<boolean> {
    console.log(`[Infra - Cybersource] Iniciando transacci√≥n SOAP/REST...`);
    console.log(`[Infra - Cybersource] Cobrando ${amount} ${currency} a tarjeta ${source}`);
    return true; // Simula √©xito
  }
}

================================================================================
FILE: infrastructure/payment/LyraPaymentGateway.ts
================================================================================
/**
 * Archivo: LyraPaymentGateway.ts
 * UBICACI√ìN: Capa de Infraestructura / Payment
 *
 * Implementaci√≥n concreta para Lyra.
 */

import { IPaymentGateway } from '../../domain/interfaces/IPaymentGateway';

export class LyraPaymentGateway implements IPaymentGateway {
  async processPayment(amount: number, currency: string, source: string): Promise<boolean> {
    console.log(`[Infra - Lyra] Redirigiendo a pasarela de pago segura...`);
    console.log(`[Infra - Lyra] Procesando pago de ${amount} ${currency}`);
    return true; // Simula √©xito
  }
}

================================================================================
FILE: infrastructure/queue/AwsSqsClient.ts
================================================================================
/**
 * Archivo: AwsSqsClient.ts
 * UBICACI√ìN: Capa de Infraestructura / Queue
 *
 * Implementaci√≥n concreta para AWS SQS.
 */

import { IQueueService } from '../../domain/interfaces/IQueueService';

export class AwsSqsClient implements IQueueService {
  async publishMessage(queueName: string, message: any): Promise<void> {
    console.log(`[Infra - AWS SQS] Enviando mensaje a https://sqs.us-east-1.amazonaws.com/123/${queueName}`);
    console.log(`[Infra - AWS SQS] Body: ${JSON.stringify(message)}`);
  }
}

================================================================================
FILE: infrastructure/queue/RabbitMqClient.ts
================================================================================
/**
 * Archivo: RabbitMqClient.ts
 * UBICACI√ìN: Capa de Infraestructura / Queue
 *
 * Implementaci√≥n concreta para RabbitMQ (u otro cloud).
 */

import { IQueueService } from '../../domain/interfaces/IQueueService';

export class RabbitMqClient implements IQueueService {
  async publishMessage(queueName: string, message: any): Promise<void> {
    console.log(`[Infra - RabbitMQ] Publicando en exchange 'events', routingKey '${queueName}'`);
    console.log(`[Infra - RabbitMQ] Payload: ${JSON.stringify(message)}`);
  }
}

================================================================================
FILE: infrastructure/repositories/MongoUserRepository.ts
================================================================================
import { IUserRepository } from '../../domain/interfaces/IUserRepository';
import { User } from '../../domain/entities/User';
import { UserDocument } from '../dtos/UserDocument';
import { MongoUserMapper } from '../mappers/MongoUserMapper';

export class MongoUserRepository implements IUserRepository {
  
  // Simulamos el Driver de MongoDB (como si fuera 'mongoose' o 'mongodb native driver')
  private db = {
    collection: (name: string) => ({
      insertOne: async (doc: any): Promise<any> => {
        console.log(`[Mongo Driver] db.${name}.insertOne(${JSON.stringify(doc)})`);
        return { acknowledged: true, insertedId: doc._id };
      },
      findOne: async (query: any): Promise<any> => {
        console.log(`[Mongo Driver] db.${name}.findOne(${JSON.stringify(query)})`);
        
        // SIMULACI√ìN: Si buscamos por ID 123, devolvemos algo, si no null
        if (query._id === 'user_123' || query['$or']) { // Hack simple para simulacion
           return null; // Simulamos no encontrado por defecto para el ejemplo
        }
        return null;
      }
    })
  };

  async save(user: User): Promise<User> {
    // 1. Dominio -> Documento BSON (DTO)
    const userDoc = MongoUserMapper.toPersistence(user);

    // 2. Persistencia (Infraestructura Pura)
    // Mongo usa upsert o insertOne/updateOne. Aqu√≠ simulamos insert.
    await this.db.collection('users').insertOne(userDoc);

    return user;
  }

  async findByEmail(email: string): Promise<User | null> {
    // 1. Consulta BSON
    const doc = await this.db.collection('users').findOne({ email: email });

    // 2. Si no hay documento, retornamos null
    if (!doc) return null;

    // 3. Reconstituci√≥n (BSON -> User Entity)
    return MongoUserMapper.toDomain(doc as UserDocument);
  }

  async findById(id: string): Promise<User | null> {
    // 1. Consulta BSON por _id
    // Nota: en la vida real user._id puede ser ObjectId, aqu√≠ usamos string
    console.log(`[Mongo Driver] db.users.findOne({ _id: '${id}' })`);

    // SIMULACI√ìN DE RETORNO DE DRIVER
    const mockDoc: UserDocument = {
      _id: id,
      email: "found@mongo.com",
      password_hash: "secret_hash_mongo",
      is_active: true, // Boolean nativo
      created_at: new Date()
    };

    // 2. Transformaci√≥n
    return MongoUserMapper.toDomain(mockDoc);
  }
}

================================================================================
FILE: infrastructure/repositories/SqlUserRepository.ts
================================================================================
import { IUserRepository } from '../../domain/interfaces/IUserRepository';
import { User } from '../../domain/entities/User';
import { UserPersistenceDTO } from '../dtos/UserPersistenceDTO';
import { UserMapper } from '../mappers/UserMapper';

export class SqlUserRepository implements IUserRepository {
  
  // Simulamos un "Pool de Conexiones" o Driver de Base de Datos
  private db = {
    query: async (sql: string, params: any[]): Promise<any[]> => {
      console.log(`[DB Driver] Executing SQL: ${sql} | Params: ${JSON.stringify(params)}`);
      // Esto retornar√≠a datos 'raw' de la BD (JSON o filas)
      return []; 
    }
  };

  async save(user: User): Promise<User> {
    // 1. Dominio -> Datos de Persistencia (DTO)
    // El repositorio convierte la entidad limpia en datos sucios/planos
    const persistenceData = UserMapper.toPersistence(user);

    // 2. Ejecutar Query (Infraestructura Pura)
    const sql = `
      INSERT INTO users (id, email, password_hash, is_active, created_at)
      VALUES (?, ?, ?, ?, ?)
      ON DUPLICATE KEY UPDATE 
      email = VALUES(email), 
      is_active = VALUES(is_active)
    `;
    
    await this.db.query(sql, [
      persistenceData.user_id,
      persistenceData.email_address,
      persistenceData.password_hash,
      persistenceData.is_active,
      persistenceData.created_at
    ]);

    return user;
  }

  async findByEmail(email: string): Promise<User | null> {
    // 1. Query a la BD
    const sql = "SELECT * FROM users WHERE email_address = ? LIMIT 1";
    const rows = await this.db.query(sql, [email]);

    // Simulamos que la BD no encontr√≥ nada
    if (rows.length === 0) {
      // Nota: Aqu√≠ podr√≠amos devolver datos hardcodeados para probar si quieres
      return null; 
    }

    // 2. Datos Crudos (DTO) -> Recibidos del driver
    const rawUser: UserPersistenceDTO = rows[0];

    // 3. Reconstituci√≥n (Infra -> Dominio)
    // Usamos el Mapper para crear la entidad m√°gicamente
    return UserMapper.toDomain(rawUser);
  }

  async findById(id: string): Promise<User | null> {
    const sql = "SELECT * FROM users WHERE id = ? LIMIT 1";
    // SIMULACI√ìN: Vamos a fingir que la BD S√ç encontr√≥ al usuario para el ejemplo
    console.log(`[DB Driver] Executing SQL: ${sql} | Params: ["${id}"]`);

    // DATO CRUDO SIMULADO (Lo que devolver√≠a el driver de MySQL/Postgres)
    const mockDbRow: UserPersistenceDTO = {
      user_id: id,
      email_address: "found@sql.com",
      password_hash: "hashed_secret_123",
      is_active: 1, // ¬°F√≠jate! Es un n√∫mero, no un boolean
      created_at: "2023-01-01T10:00:00Z"
    };

    // Mapeo: DTO -> Entity
    return UserMapper.toDomain(mockDbRow);
  }
}

================================================================================
FILE: main.ts
================================================================================
/**
 * Archivo: main.ts
 * UBICACI√ìN: Ra√≠z de la Aplicaci√≥n (Composition Root)
 *
 * Aqu√≠ es donde ocurre la MAGIA de la Inyecci√≥n de Dependencias.
 * Decidimos QU√â implementaciones usar sin tocar el c√≥digo de negocio.
 */

// Importamos Interfaces (Puertos)
import { IUserRepository } from './domain/interfaces/IUserRepository';
import { IEmailService } from './domain/interfaces/IEmailService';
import { IPaymentGateway } from './domain/interfaces/IPaymentGateway';
import { IQueueService } from './domain/interfaces/IQueueService';

// Importamos Implementaciones (Adaptadores)
import { SqlUserRepository } from './infrastructure/repositories/SqlUserRepository';
import { MongoUserRepository } from './infrastructure/repositories/MongoUserRepository';
import { SmtpEmailClient } from './infrastructure/email/SmtpEmailClient';
import { CybersourcePaymentGateway } from './infrastructure/payment/CybersourcePaymentGateway';
import { LyraPaymentGateway } from './infrastructure/payment/LyraPaymentGateway';
import { AwsSqsClient } from './infrastructure/queue/AwsSqsClient';
import { RabbitMqClient } from './infrastructure/queue/RabbitMqClient';

// Importamos Servicios de Dominio
import { UserService } from './domain/services/UserService';
import { OrderService } from './domain/services/OrderService';

// Importamos Controladores y Vistas
import { UserController } from './presentation/controllers/UserController';
import { OrderController } from './presentation/controllers/OrderController';
import { ConsoleView } from './presentation/views/ConsoleView';

async function main() {
  console.log("üöÄ Iniciando Sistema con Arquitectura Limpia...\n");

  // 1. CAPA DE INFRAESTRUCTURA (Elegimos las herramientas)
  // Podemos cambiar estas l√≠neas y TODO el sistema cambia de tecnolog√≠a
  // sin tocar una sola l√≠nea de l√≥gica de negocio.
  
  // const userRepo: IUserRepository = new SqlUserRepository(); // Opci√≥n A
  const userRepo: IUserRepository = new MongoUserRepository(); // Opci√≥n B

  const emailService: IEmailService = new SmtpEmailClient();
  
  // const paymentGateway: IPaymentGateway = new CybersourcePaymentGateway(); // Opci√≥n A
  const paymentGateway: IPaymentGateway = new LyraPaymentGateway(); // Opci√≥n B

  const queueService: IQueueService = new AwsSqsClient();
  // const queueService: IQueueService = new RabbitMqClient();

  // 2. CAPA DE DOMINIO (Inyectamos las herramientas)
  const userService = new UserService(userRepo, emailService);
  const orderService = new OrderService(paymentGateway, queueService, emailService);

  // 3. CAPA DE PRESENTACI√ìN (Conectamos con el mundo exterior)
  const view = new ConsoleView();
  const userController = new UserController(userService, view);
  const orderController = new OrderController(orderService, view);

  // --- SIMULACI√ìN DE USO ---

  // CASO 1: Registrar Usuario
  await userController.register({ 
    email: "andy@gmail.com", 
    password: "superSecurePassword" 
  });

  // CASO 2: Crear Orden con Items (Ejemplo de Agregado)
  await orderController.createOrder({
    userId: "user_123",
    items: [
      { productId: "p1", price: 50.00, quantity: 1 },
      { productId: "p2", price: 100.00, quantity: 1 } // Total should be 150.00
    ],
    paymentSource: "tok_visa_4242"
  });

  // CASO 3: Intento de registro fallido (Regla de Negocio)
  await userController.register({ 
    email: "hacker@evil.com", 
    password: "123" 
  });
}

main().catch(console.error);

================================================================================
FILE: presentation/controllers/OrderController.ts
================================================================================
/**
 * Archivo: OrderController.ts
 * UBICACI√ìN: Capa de Presentaci√≥n / Controladores
 *
 * Controlador para gestionar √≥rdenes.
 */

import { OrderService } from '../../domain/services/OrderService';
import { CreateOrderDto } from '../dtos/CreateOrderDto';
import { ConsoleView } from '../views/ConsoleView';

export class OrderController {
  constructor(
    private readonly orderService: OrderService,
    private readonly view: ConsoleView
  ) {}

  async createOrder(request: CreateOrderDto): Promise<void> {
    console.log("\n--- [Controller] Recibiendo solicitud de orden ---");

    try {
      // 1. Validaci√≥n (Ahora validamos la lista de items)
      if (!request.items || !Array.isArray(request.items) || request.items.length === 0) {
        throw new Error("Bad Request: La orden debe tener items.");
      }

      // 2. Delegaci√≥n
      const order = await this.orderService.createOrder(
        request.userId, 
        request.items, 
        request.paymentSource
      );

      // 3. Respuesta
      this.view.renderSuccess(order);

    } catch (error: any) {
      this.view.renderError(error.message);
    }
  }
}

================================================================================
FILE: presentation/controllers/UserController.ts
================================================================================
/**
 * Archivo: UserController.ts
 * UBICACI√ìN: Capa de Presentaci√≥n / Controladores
 *
 * ¬øQU√â HACE UN CONTROLADOR?
 * - Recibe la petici√≥n (Request).
 * - Valida el formato de entrada (DTOs).
 * - Llama al Servicio de Dominio adecuado.
 * - Formatea la respuesta (Serializer).
 * - Retorna la respuesta (Response).
 */

import { UserService } from '../../domain/services/UserService';
import { RegisterUserDto } from '../dtos/RegisterUserDto';
import { UserSerializer } from '../serializers/UserSerializer';
import { ConsoleView } from '../views/ConsoleView';

export class UserController {
  constructor(
    private readonly userService: UserService,
    private readonly view: ConsoleView
  ) {}

  async register(request: RegisterUserDto): Promise<void> {
    console.log("\n--- [Controller] Recibiendo solicitud de registro ---");

    try {
      // 1. Validaci√≥n b√°sica de entrada (Input Validation)
      if (!request.email || !request.email.includes('@')) {
        throw new Error("Bad Request: Email inv√°lido");
      }
      if (!request.password || request.password.length < 6) {
        throw new Error("Bad Request: Password muy corto");
      }

      // 2. Delegaci√≥n al Servicio de Dominio
      const user = await this.userService.registerUser(request.email, request.password);

      // 3. Serializaci√≥n y Respuesta
      const response = UserSerializer.serialize(user);
      this.view.renderSuccess(response);

    } catch (error: any) {
      // 4. Manejo de Errores
      this.view.renderError(error.message);
    }
  }
}

================================================================================
FILE: presentation/dtos/CreateOrderDto.ts
================================================================================
/**
 * Archivo: CreateOrderDto.ts
 * UBICACI√ìN: Capa de Presentaci√≥n / DTOs
 *
 * Estructura de datos para crear una orden.
 */

export interface CreateOrderDto {
  userId: string;
  items: Array<{
    productId: string;
    price: number;
    quantity: number;
  }>;
  paymentSource: string; // Token de tarjeta, ID de cuenta, etc.
}

================================================================================
FILE: presentation/dtos/RegisterUserDto.ts
================================================================================
/**
 * Archivo: RegisterUserDto.ts
 * UBICACI√ìN: Capa de Presentaci√≥n / DTOs
 *
 * ¬øQU√â ES UN DTO (Data Transfer Object)?
 * - Es un objeto simple para transportar datos entre procesos.
 * - Define QU√â datos esperamos recibir del cliente (frontend/API).
 * - NO tiene l√≥gica de negocio.
 */

export interface RegisterUserDto {
  email: string;
  password: string;
}

================================================================================
FILE: presentation/serializers/UserSerializer.ts
================================================================================
/**
 * Archivo: UserSerializer.ts
 * UBICACI√ìN: Capa de Presentaci√≥n / Serializers
 *
 * ¬øQU√â HACE UN SERIALIZER?
 * - Transforma objetos de dominio en respuestas para el cliente.
 * - Oculta datos sensibles (como passwordHash).
 * - Formatea fechas, monedas, etc.
 */

import { User } from '../../domain/entities/User';

export class UserSerializer {
  static serialize(user: User): any {
    return {
      id: user.id,
      email: user.email,
      status: user.isActive ? 'Active' : 'Inactive',
      // NO devolvemos passwordHash
    };
  }
}

================================================================================
FILE: presentation/views/ConsoleView.ts
================================================================================
/**
 * Archivo: ConsoleView.ts
 * UBICACI√ìN: Capa de Presentaci√≥n / Vistas
 *
 * Simula una "Vista" que renderiza la respuesta.
 * En una API REST, esto ser√≠a el JSON response.
 * En una web MVC, ser√≠a el HTML.
 */

export class ConsoleView {
  renderSuccess(data: any): void {
    console.log("\n‚úÖ [VISTA] Respuesta Exitosa:");
    console.log(JSON.stringify(data, null, 2));
  }

  renderError(error: string): void {
    console.log("\n‚ùå [VISTA] Error:");
    console.log(`   ${error}`);
  }
}
